<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" hreflang="en" /><updated>2025-02-04T04:38:10+00:00</updated><id>/feed.xml</id><title type="html">Emily Lewis Dando</title><subtitle>Give me a job. 
</subtitle><author><name>&lt;firstname&gt; &lt;lastname&gt;</name><email>&lt;mail@domain.tld&gt;</email></author><entry><title type="html">Probability Basics</title><link href="/blog/2025-02-02-Probability-Basics/" rel="alternate" type="text/html" title="Probability Basics" /><published>2025-02-02T00:00:00+00:00</published><updated>2025-02-04T03:53:47+00:00</updated><id>/blog/Probability-Basics</id><content type="html" xml:base="/blog/2025-02-02-Probability-Basics/"><![CDATA[<p>Probability has never felt intuitive to me, however in undergoing a degree in Data Science and Statistics, it must become intuitive. I have compiled a few key areas of probability and counting to serve as guiding principles when dealing with probability.</p>

<h3 id="key-rules">Key rules</h3>
<h3 id="binomial-distributions">Binomial Distributions</h3>
<ul>
  <li>Requirements
    <ul>
      <li>Always with replacement</li>
      <li>Must have binary outcomes for each trial</li>
      <li>Must know number of trials</li>
      <li>Probability does not change over time</li>
    </ul>
  </li>
  <li>Data
    <ul>
      <li>$n$: The number of trials</li>
      <li>$p$: Probability of 1 success</li>
      <li>$1-p$: Probability of 1 failure</li>
      <li>$x$: Number of successes</li>
    </ul>
  </li>
  <li>Parameters
    <ul>
      <li>EV of Sum: $n\cdot p$</li>
      <li>SE of Sum: $\sqrt{n\cdot p \cdot (1-p)}$</li>
    </ul>
  </li>
  <li>Formula
    <ul>
      <li>$P(X=x) ={n \choose x}p^x(1-p)^{n-x}$
        <ul>
          <li>$p^x(1-p)^{n-x}$: Say that we are rolling a dice. We want to know the probability that we roll ‘3’ twice out of 5 rolls. This part of the equation tells us, what is the chance that we win (roll 3) 2 times and fail 3 times. It is like saying $(P(succeed) \cdot 2)\cdot(P(fail) \cdot 3)$. But, this only tells us the chance of it happening in one way: succeed, succeed, fail, fail, fail. Now we need to find the probability for all possible combinations.</li>
          <li>${n\choose x}$: See <em>Counting - Combinations</em> for more explanation - this gives the total number of ways for $x$ successes out of $n$ trials. When we multiply the probability we calculated in the step above, then we have the probability of this combination of events happening, multiplied by the number of ways (ordering) it can happen. The formula is $\frac{n!}{(n-x)!x!}$.
            <h3 id="counting">Counting</h3>
            <h4 id="combinations">Combinations</h4>
            <h4 id="permutations">Permutations</h4>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>]]></content><author><name>&lt;firstname&gt; &lt;lastname&gt;</name><email>&lt;mail@domain.tld&gt;</email></author><category term="blog" /><summary type="html"><![CDATA[Probability has never felt intuitive to me, however in undergoing a degree in Data Science and Statistics, it must become intuitive. I have compiled a few key areas of probability and counting to serve as guiding principles when dealing with probability.]]></summary></entry><entry><title type="html">Shell Cheatsheet</title><link href="/blog/2025-01-10-unix-cheatsheet/" rel="alternate" type="text/html" title="Shell Cheatsheet" /><published>2025-01-10T00:00:00+00:00</published><updated>2025-02-04T02:44:51+00:00</updated><id>/blog/unix-cheatsheet</id><content type="html" xml:base="/blog/2025-01-10-unix-cheatsheet/"><![CDATA[<h6 id="print-statements">print statements</h6>
<pre><code class="language-run-shell">echo (-n: don't print newline) "message" #prints message
</code></pre>
<h6 id="filtering">filtering</h6>
<pre><code class="language-run-shell">grep (-v: select everything not including the following) (-E extended regex) (-o: print all occurences of matching pattern) (-c count number of lines matching) [pattern] [filename] #filters [filename] for [pattern]
</code></pre>
<pre><code class="language-run-shell">#grep and strings
right=hello
wrong=bye
echo $right | grep -E "^h"
echo $wrong | grep -E "^h" #won't print if it does not match the condition
</code></pre>
<h6 id="word-counts">word counts</h6>
<pre><code class="language-run-shell">wc (-n: omit newline) (-c: bytecount) (-l: count lines) (-m: count chars) [file/string] #counts (byte/lines/chars/etc) of [file/string]
</code></pre>
<h6 id="sorting">sorting</h6>
<pre><code class="language-run-shell">sort (-n: sort by numerical) (-r: desc) 
head (-5) [file] #print first 5 lines
tail (-5) [file] #print last 5 lines
</code></pre>
<h6 id="user-input">user input</h6>
<pre><code class="language-run-shell">read (-p: add message) "message" [variable_name] #saves user response to "message" to [variable_name]
echo $variable_name
</code></pre>
<h6 id="arithmetic">arithmetic</h6>
<pre><code class="language-run-shell">#base shell
expr \( 4 + 2 - 3 \) \* 5 
echo "$(expr \( 4 + 2 - 3 \) \* 5)" #prints it

declare (-i: integer type) (-r: readonly) [variable_name]=4 #set integer type variable - try to set it to string later and it will be set to 0

answer=`expr 5 + 5` #command substitution - set variable to product of commands
</code></pre>
<pre><code class="language-run-shell">#bash specific
answer=$(( (4+2-3)*5 )) #math operations
echo $answer
</code></pre>
<h6 id="regex">regex</h6>
<pre><code class="language-run-shell">#basic conditions
grep (-E: doesn't require backslashes) "^ex|er$" [filename] #begins with ex OR ends with er

grep -E "^[Ff][0-9]" [filename] #starts with F or F then anything from 0-9 (e.g F9, f5)

grep -E -v "[[:digit:]][[:punct:]]" [filename] #doesnt include digit/punctuation

[[:alpha:]] #any uppercase or lowercase english letter
[[:upper:]] #lowercase english letters
[[:digit:]] #0-9
[[:alnum:]] #alpha or digit
[[:xdigit:]] # digit or upper/lower [a:f]
[[:punct:]] #punctutation
. # any character
"e$" #end in e
"^e" #start with e
</code></pre>

<h6 id="working-with-csv">working with csv</h6>

<pre><code class="language-run-shell">cut (-d - delimiter) , (-f - select certain fields) 3-4 #cut out the 3rd and 4th field separated by commas

#returns unique values - NOTE: must sort before passing into the command
uniq (-c: returns distinct values + number of occurences)
uniq myfile # will take the first value if there are multiple
</code></pre>]]></content><author><name>&lt;firstname&gt; &lt;lastname&gt;</name><email>&lt;mail@domain.tld&gt;</email></author><category term="blog" /><summary type="html"><![CDATA[A quick reference sheet for the basics of unix shell!]]></summary></entry></feed>